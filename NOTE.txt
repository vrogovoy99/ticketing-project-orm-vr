1. Sequence of development:

1.1. Controllers are build
1.2. Controllers call ServiceImpl via Service interface
1.3. ServiceImpl call Repository interface (to utilize JPArepository library)
1.4. ServiceImpl utilizes ModelMapper to conver entity to DTO objects.
1.5. Mapper bean is created in Main application run class.


Controller -> Service Interface -> ServiceImpl -> Repository + Mappers

2. After adding in BaseEntity private boolean isDeleted=false;
    to select only "non-deleted" records for the entities add annotation in class definition:

        @Where(clause = "is_deleted=false")

3. Sequence to add new entity

    3.1. Create Entity class
    3.2. Create Entity service
    3.3. Create Entity repository
    3.4. Create Entity mapper (ModelMapper for Entity<>DTO)
    3.5. Create Entity converter  (map string to DTO object pulling data from database - used in case of dropdowns to convert passed id into object)
    3.6. In case of circular dependency loop add @Lazy in entity converter constructor Like:

            public ProjectDtoConverter(@Lazy ProjectService projectService) {
            }

            @Lazy goes into constructor to manifest any dependant class as Lazy

4. create automatic triggers to populate data (BaseEntity for update/insert fields)

    4.1. @PrePersist - method used on insert
    4.2. @PreUpdate - method used on update
    4.3. @Column(nullable = false, updatable = false) - to prevent nullification of the field

5. Enforce unique values in a column Project.ProjectCode

        @Column(unique = true)
        private String projectCode;

6. Security

    6.1. add dependencies

        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>

        that creates user: user
        password: Using generated security password from console during boot.

    6.2. add bean in start class for the password encoder

        	@Bean
        	public PasswordEncoder passwordEncoder(){
        		return new BCryptPasswordEncoder();
        	}

    6.3. add SecurityConfig @Configuration class in config package returning UserDetailService to load application users in memory for later authentication.

            @Bean
            public UserDetailsService userDetailsService(PasswordEncoder encoder){
                List<UserDetails> userList = new ArrayList<>();
                //add multiple users
                userList.add(
                        new User( "mike", encoder.encode("password"), Arrays.asList(new SimpleGrantedAuthority("ROLE_ADMIN"))));
                        new User( "ozzy", encoder.encode("password"), Arrays.asList(new SimpleGrantedAuthority("ROLE_MANAGER")));
                return new InMemoryUserDetailsManager(userList);
            }


            [ UI ] <- [ UserDetailService ]         [ Repository ]  -> [ DB ]
                            ^
                      [ UserDetail] <- User

    6.4. configure application access based on user role in SecurityConfig class:

             @Bean
             public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

                 return http
                         .authorizeRequests()
                          //alternative ways to assing path to a role
                         .antMatchers("/task/**").hasRole("EMPLOYEE")
                         .antMatchers("/task/**").hasAnyRole("EMPLOYEE", "ADMIN")
                         .antMatchers("task/**").hasAuthority("ROLE_EMPLOYEE")
                         .antMatchers("/",      //list path impacted by security rules
                                 "/login",
                                 "/fragments/**",
                                 "/assets/**",
                                 "/images/**")
                         .permitAll()           // grant access permit to above http locations
                         .anyRequest().authenticated()
                         .and()
                         .httpBasic()           //type of login screen
                         .and().build();